<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>堆与栈 | canaan</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="The place is canaan">
    <link rel="preload" href="/test/assets/css/0.styles.096a998f.css" as="style"><link rel="preload" href="/test/assets/js/app.d0cc9b25.js" as="script"><link rel="preload" href="/test/assets/js/2.9ead390f.js" as="script"><link rel="preload" href="/test/assets/js/3.3a99d1c0.js" as="script"><link rel="prefetch" href="/test/assets/js/10.9d0f767c.js"><link rel="prefetch" href="/test/assets/js/11.3b56b223.js"><link rel="prefetch" href="/test/assets/js/12.733ed882.js"><link rel="prefetch" href="/test/assets/js/13.9780de12.js"><link rel="prefetch" href="/test/assets/js/14.3b0d6c5c.js"><link rel="prefetch" href="/test/assets/js/15.1a8c2a70.js"><link rel="prefetch" href="/test/assets/js/16.616df467.js"><link rel="prefetch" href="/test/assets/js/17.5c74f2b2.js"><link rel="prefetch" href="/test/assets/js/18.8c83db77.js"><link rel="prefetch" href="/test/assets/js/19.2b7be8df.js"><link rel="prefetch" href="/test/assets/js/20.d3f1f092.js"><link rel="prefetch" href="/test/assets/js/21.59a768ec.js"><link rel="prefetch" href="/test/assets/js/22.61974d7e.js"><link rel="prefetch" href="/test/assets/js/23.d20c4190.js"><link rel="prefetch" href="/test/assets/js/24.fb0d82e3.js"><link rel="prefetch" href="/test/assets/js/25.8584da35.js"><link rel="prefetch" href="/test/assets/js/26.7d5bd709.js"><link rel="prefetch" href="/test/assets/js/4.3bec5bdb.js"><link rel="prefetch" href="/test/assets/js/5.f5002a1d.js"><link rel="prefetch" href="/test/assets/js/6.1571726f.js"><link rel="prefetch" href="/test/assets/js/7.12d98ad9.js"><link rel="prefetch" href="/test/assets/js/8.676f34a5.js"><link rel="prefetch" href="/test/assets/js/9.f92225e1.js">
    <link rel="stylesheet" href="/test/assets/css/0.styles.096a998f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test/" class="home-link router-link-active"><!----> <span class="site-name">canaan</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/test/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/test/guide/" class="nav-link">
  文档
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  链接
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/test/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/test/guide/" class="nav-link">
  文档
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  链接
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/test/blog/" aria-current="page" class="sidebar-link">关于</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/blog/iOS/0.ram.html" aria-current="page" class="active sidebar-link">内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#堆与栈" class="sidebar-link">堆与栈</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#引用计数器" class="sidebar-link">引用计数器</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#自动释放池" class="sidebar-link">自动释放池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#原理" class="sidebar-link">原理</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#创建" class="sidebar-link">创建</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#触发" class="sidebar-link">触发</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#mrc" class="sidebar-link">MRC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#自己生成的对象，自己持有" class="sidebar-link">自己生成的对象，自己持有</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#非自己生成的对象，自己也能持有" class="sidebar-link">非自己生成的对象，自己也能持有</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#不再需要自己持有的对象时释放" class="sidebar-link">不再需要自己持有的对象时释放</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#非自己持有的对象无法释放" class="sidebar-link">非自己持有的对象无法释放</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#arc" class="sidebar-link">ARC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#修饰符" class="sidebar-link">修饰符</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#arc及mrc的属性" class="sidebar-link">arc及mrc的属性</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#arc规则" class="sidebar-link">ARC规则</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#mrc到arc的转变" class="sidebar-link">mrc到arc的转变</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#内存泄露" class="sidebar-link">内存泄露</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#循环引用" class="sidebar-link">循环引用</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#core-foundation-对象" class="sidebar-link">Core Foundation 对象</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#block内存管理" class="sidebar-link">Block内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#block-的内存管理：" class="sidebar-link">block 的内存管理：</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#copy-block" class="sidebar-link">Copy block</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#block内存类型" class="sidebar-link">block内存类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#autorelease内存管理" class="sidebar-link">Autorelease内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#_1、哪些对象是autorelease管理的？" class="sidebar-link">1、哪些对象是autorelease管理的？</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#_2、autoreleasepool什么时候创建的，里面的对象又是什么时候释放的？" class="sidebar-link">2、autoreleasePool什么时候创建的，里面的对象又是什么时候释放的？</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#weak对象内存管理" class="sidebar-link">weak对象内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#_1、释放时机" class="sidebar-link">1、释放时机</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#_2、如何实现" class="sidebar-link">2、如何实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#nsstring内存管理" class="sidebar-link">NSString内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#_1、nsstring内存的类型" class="sidebar-link">1、NSString内存的类型</a></li><li class="sidebar-sub-header"><a href="/test/blog/iOS/0.ram.html#_2、两种内存类型的创建时机。" class="sidebar-link">2、两种内存类型的创建时机。</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>随笔</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="堆与栈"><a href="#堆与栈" class="header-anchor">#</a> 堆与栈</h2> <p>1.栈区(stack):由编译器自动分配释放，函数的参数值，局部变量等值。<br>
2.堆区(heap):一般由开发人员分配释放，若不释放，则可能会引起内存泄漏。
<img src="/test/assets/img/mem.94749375.jpeg" alt="内存分布"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>NSString* string = @&quot;sdfsdf&quot;;//常量string-&gt;栈
NSMutableString* mString = [[NSMutableString alloc] initWithString:@&quot;sdfsdf&quot;];//mString-&gt;堆
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="引用计数器"><a href="#引用计数器" class="header-anchor">#</a> 引用计数器</h2> <p>ObjC采用引用计数（reference counting）技术来进行内存管理：</p> <ol><li>每个对象都有一个关联的整数，称为引用计数器</li> <li>当代码需要使用该对象时，则将对象的引用计数加1</li> <li>当代码结束使用该对象时，则将对象的引用计数减1</li> <li>当引用计数的值变为0时，此时对象将被释放。</li></ol> <p>与之对应的消息发送方法如下：</p> <ol><li>当对象被创建（alloc、new或copy等方法）时，其引用计数初始值为1</li> <li>给对象发送retain消息，其引用计数加1</li> <li>给对象发送release消息，其引用计数减1</li> <li>当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象</li></ol> <p>例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RetainCountObject * object = [[RetainCountObject alloc]init];  // --&gt;引用计数为1
[object retain];      // --&gt;引用计数为2
[object release];     // --&gt;引用计数为1
[object release];     // --&gt;引用计数为0
object = nil;         // --&gt;销毁对象

特殊情况
NSString * str = @&quot; hello&quot;;  // --&gt;引用计数为-1，常量对象由栈管理，没有引用计数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="自动释放池"><a href="#自动释放池" class="header-anchor">#</a> 自动释放池</h2> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h3> <p>自动释放池，系统有一个现成的自动内存管理池，他会随着每一个mainRunloop的结束而释放其中的对像.自动释放池也可以手动创建，他可以让池中的对象在执行完代码后马上被释放，可以起到优化内存，防止内存溢出的效果（如视频帧图片的切换时、创建大量临时对象时等）。</p> <p>autorelease<br>
延迟释放，注册到autoreleasepool(自动释放池)中，等到pool结束时释放池再自动调用release进行释放.每个Runloop中都创建一个Autorelease pool（自动释放池），每一次的Autorelease，系统都会把该Object放入了当前的Autorelease pool中，并在Runloop的末尾进行释放，而当该pool被释放时，该pool中的所有Object会被调用Release。 所以，一般情况下，每个接受autorelease消息的对象，都会在下个Runloop开始前被释放</p> <p>release<br>
立即释放</p> <p>autorelease的具体使用方法如下</p> <ul><li>生成并持有NSAutoreleasePool对象。</li> <li>调用已分配对象的autorelease实例方法。</li> <li>废弃NSAutoreleasePool对象。</li></ul> <h3 id="创建"><a href="#创建" class="header-anchor">#</a> 创建</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>MRC：
NSAutoreleasePool* pool = [[NSAutoreleasePool alloc]init];
// do something
id obj = [[NSMutableArray alloc] init];
[obj autorelease];
[pool release];
// [pool drain];//GC（垃圾回收机制）环境没影响

ARC：
@autoReleasePool{
   id __autoreleasing obj2;
   obj2 = obj;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>调用过autorelease实例方法的对象（MRC，同ARC使用__autoreleasing修饰符的对象）被加入到了autoreleasepool,在pool release时，这些被加入的对象将调用release进行释放.autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>- (id) autorelease {
    [NSAutoreleasePool addObject: self];
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="触发"><a href="#触发" class="header-anchor">#</a> 触发</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>- (void)autoRelease_Test {
    @autoreleasepool {
        TestModel *model = [[TestModel alloc] init];
        [model autorelease];
        //model can dongSomething you want
        NSLog(@&quot;自动释放：end&quot;);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>MRC_Project[2678:287011] 自动释放：end<br>
MRC_Project[2678:287011] TestModel dealloc<br>
可以看到，当自动释放调用后，model对象才被释放，因此在池子释放之前，model可以正常调用。</p> <h2 id="mrc"><a href="#mrc" class="header-anchor">#</a> MRC</h2> <h3 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="header-anchor">#</a> 自己生成的对象，自己持有</h3> <p>当new、alloc、copy、mutableCopy创建一个对象时只有自己持有，引用计数为1</p> <h3 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="header-anchor">#</a> 非自己生成的对象，自己也能持有</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//非自己生成的对象，暂时没有持有
id obj = [NSMutableArray array];
//通过retain持有对象
[obj retain];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上述代码中NSMutableArray通过类方法array生成了一个对象赋给变量obj，但变量obj自己并不持有该对象。使用retain方法可以持有对象。</p> <h3 id="不再需要自己持有的对象时释放"><a href="#不再需要自己持有的对象时释放" class="header-anchor">#</a> 不再需要自己持有的对象时释放</h3> <p>自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用release方法</p> <ul><li>自己生成并持有对象的释放</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 自己生成并持有对象
id obj = [[NSObject alloc] init];
//释放对象
[obj release];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>非自己生成的对象持有对象的释放</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//非自己生成的对象，暂时没有持有
id obj = [NSMutableArray array];

//通过retain持有对象
[obj retain];

//释放对象
[obj release];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>非自己生成的对象本身的释放</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>+ (id)array {
    //生成并持有对象
    id obj = [[NSMutableArray alloc] init];

    //使用autorelease不持有对象
    [obj autorelease];

    //返回对象
    return obj;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="非自己持有的对象无法释放"><a href="#非自己持有的对象无法释放" class="header-anchor">#</a> 非自己持有的对象无法释放</h3> <p>对于用alloc/new/copy/mutableCopy方法生成并持有的对象，或是用retain方法持有的对象，由于持有者是自己，所以在不需要该对象时需要将其释放。而由此以外所得到的对象绝对不能释放。倘若在程序中释放了非自己所持有的对象就会造成崩溃。</p> <h2 id="arc"><a href="#arc" class="header-anchor">#</a> ARC</h2> <p>一个编译器级的能简化应用中对象内存管理流程的功能。它并非运行时的特性，也不是如java中的GC运行时的垃圾回收系统。在编译阶段，编译器将在项目代码中自动为分配对象插入retain、release、copy、autorelease和autoreleasepool，且插入的代码不可见。ARC模式下引用计数规则还起作用，只是编译器会为开发者分担大部分的内存管理工作，除了插入上述代码，还有一部分优化以及分析内存的管理工作。
例如</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>-(void)setup
{
    per = [person new];
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在手工管理内存的环境下，per是不会自动保留其值，而在ARC下编译，其代码会变成：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>-(void)setup
{
    person *tmp = [person new];
    per = [tmp retain];
    [tmp release];
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>ARC系统在自动调用这些方法时，并不通过普通的Objective-C消息派发控制，而是直接调用底层C语言的方法：比如retain，ARC在分析到某处需要调用保留操作的地方，调用了与retain等价的底层函数 objc_retain，所以这也是ARC下不能覆写retain、release或者autorelease的原因，因为这些方法在ARC从来不会被直接调用</p> <h3 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h3> <h4 id="strong"><a href="#strong" class="header-anchor">#</a> __strong</h4> <p>强引用，对应定义 property 时用到的 strong。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。__strong 修饰符是 id 类型和对象类型默认的所有权修饰符。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    id __strong obj = [[NSObject alloc] init];
}

//编译器的模拟代码
id obj = objc_msgSend(NSObject,@selector(alloc));
objc_msgSend(obj,@selector(init));

// 出作用域的时候调用
objc_release(obj);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>虽然ARC有效时不能使用release方法，但由此可知编译器自动插入了release。<br>
对象是通过除alloc、new、copy、multyCopy外方法产生的情况</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    id __strong obj = [NSMutableArray array];
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>结果与之前稍有不同：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//编译器的模拟代码
id obj = objc_msgSend(NSMutableArray,@selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_release(obj);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>objc_retainAutoreleasedReturnValue函数主要用于优化程序的运行。它是用于持有(retain)对象的函数，它持有的对象应为返回注册在autoreleasePool中对象的方法，或是函数的返回值。像该源码这样，在调用array类方法之后，由编译器插入该函数。</p> <p>而这种objc_retainAutoreleasedReturnValue函数是成对存在的，与之对应的函数是objc_autoreleaseReturnValue。它用于array类方法返回对象的实现上。下面看看NSMutableArray类的array方法通过编译器进行了怎样的转换：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>+ (id)array
{
    return [[NSMutableArray alloc] init];
}

//编译器模拟代码
+ (id)array
{
    id obj = objc_msgSend(NSMutableArray,@selector(alloc));
    objc_msgSend(obj,@selector(init));

    // 代替我们调用了autorelease方法
    return objc_autoreleaseReturnValue(obj);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>我们可以看见调用了objc_autoreleaseReturnValue函数且这个函数会返回注册到自动释放池的对象，但是，这个函数有个特点，它会查看调用方的命令执行列表，如果发现接下来会调用objc_retainAutoreleasedReturnValue则不会将返回的对象注册到autoreleasePool中而仅仅返回一个对象。达到了一种最优效果。如下图：
<img src="/test/assets/img/arc_strong.cde51665.png" alt="strong"></p> <h4 id="weak"><a href="#weak" class="header-anchor">#</a> __weak</h4> <p>弱引用，对应定义 property 时用到的 weak。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。使用__weak修饰的变量，即是使用注册到autoreleasePool中的对象。__weak 最常见的一个作用就是用来避免循环循环。
__weak 的几个使用场景：</p> <ul><li>在 Delegate 关系中防止循环引用。</li> <li>在 Block 中防止循环引用。</li> <li>用来修饰指向由 Interface Builder 创建的控件。比如：@property (weak, nonatomic) IBOutlet UIButton *testButton;。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    id __weak obj = [[NSObject alloc] init];
}

编译器转换后的代码如下:
id obj;
id tmp = objc_msgSend(NSObject,@selector(alloc));
objc_msgSend(tmp,@selector(init));
objc_initweak(&amp;obj,tmp);
objc_release(tmp);
objc_destroyWeak(&amp;object);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>对于__weak内存管理也借助了类似于引用计数表的散列表，它通过对象的内存地址做为key，而对应的__weak修饰符变量的地址作为value注册到weak表中，在上述代码中objc_initweak就是完成这部分操作，而objc_destroyWeak则是销毁该对象对应的value。当指向的对象被销毁时，会通过其内存地址，去weak表中查找对应的__weak修饰符变量，将其从weak表中删除。所以，weak在修饰只是让weak表增加了记录没有引起引用计数表的变化.<br>
对象通过objc_release释放对象内存的动作如下:</p> <blockquote><p>objc_release<br>
因为引用计数为0所以执行dealloc<br>
_objc_rootDealloc<br>
objc_dispose<br>
objc_destructInstance<br>
objc_clear_deallocating</p></blockquote> <p>而在对象被废弃时最后调用了objc_clear_deallocating，该函数的动作如下:</p> <blockquote><p>从weak表中获取已废弃对象内存地址对应的所有记录<br>
将已废弃对象内存地址对应的记录中所有以weak修饰的变量都置为nil<br>
从weak表删除已废弃对象内存地址对应的记录<br>
根据已废弃对象内存地址从引用计数表中找到对应记录删除<br>
据此可以解释为什么对象被销毁时对应的weak指针变量全部都置为nil，同时，也看出来销毁weak步骤较多，如果大量使用weak的话会增加CPU的负荷。<br>
还需要确认一点是：使用__weak修饰符的变量，即是使用注册到autoreleasePool中的对象。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    id __weak obj1 = obj;
    NSLog(@&quot;obj2-%@&quot;,obj1);
}
编译器转换上述代码如下:
id obj1;
objc_initweak(&amp;obj1,obj);
id tmp = objc_loadWeakRetained(&amp;obj1);
objc_autorelease(tmp);
NSLog(@&quot;%@&quot;,tmp);
objc_destroyWeak(&amp;obj1);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>objc_loadWeakRetained函数获取附有__weak修饰符变量所引用的对象并retain, objc_autorelease函数将对象放入autoreleasePool中，据此当我们访问weak修饰指针指向的对象时，实际上是访问注册到自动释放池的对象。因此，如果大量使用weak的话，在我们去访问weak修饰的对象时，会有大量对象注册到自动释放池,这会影响程序的性能。</p> <p>解决方案：要访问weak修饰的变量时，先将其赋给一个strong变量，然后进行访问</p> <p>为什么访问weak修饰的对象就会访问注册到自动释放池的对象呢?</p> <p>因为weak不会引起对象的引用计数器变化，因此，该对象在运行过程中很有可能会被释放。所以，需要将对象注册到自动释放池中并在autoreleasePool销毁时释放对象占用的内存。</p> <h4 id="unsafe-unretained"><a href="#unsafe-unretained" class="header-anchor">#</a> __unsafe_unretained</h4> <p>ARC 是在 iOS5 引入的，而 __unsafe_unretained 这个修饰符主要是为了在ARC刚发布时兼容iOS4以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义property时对应的是unsafe_unretained。__unsafe_unretained 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 retainCount +1。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 nil，所以成为了野指针，非常不安全。</p> <p>__unsafe_unretained 的应用场景：</p> <p>在 ARC 环境下但是要兼容 iOS4.x 的版本，用__unsafe_unretained 替代 __weak 解决强循环循环的问题。</p> <h4 id="autoreleasing"><a href="#autoreleasing" class="header-anchor">#</a> __autoreleasing</h4> <p>将对象赋值给附有__autoreleasing修饰符的变量等同于MRC时调用对象的autorelease方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@autoeleasepool {
    // 如果看了上面__strong的原理，就知道实际上对象已经注册到自动释放池里面了
    id __autoreleasing obj = [[NSObject alloc] init];
}

编译器转换上述代码如下:
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSObject,@selector(alloc));
objc_msgSend(obj,@selector(init));
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>@autoreleasepool {
        id __autoreleasing obj = [NSMutableArray array];
    }

编译器转换上述代码如下:
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSMutableArray,@selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面两种方式，虽然第二种持有对象的方法从alloc方法变为了objc_retainAutoreleasedReturnValue函数，都是通过objc_autorelease，注册到autoreleasePool中。</p> <h3 id="arc及mrc的属性"><a href="#arc及mrc的属性" class="header-anchor">#</a> arc及mrc的属性</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//简单的赋值  
@property (nonatomic, assign) int value;     
//引用计数器加一，指针复制  
@property (nonatomic, retain) NSArray* array;   
//生成新的内存区域，内容复制  
@property (nonatomic, copy) NSString* string;   
//强引用，当所有指向同一块内存的强指针都赋空时，内存将被释放  
@property (nonatomic, strong) NSNumber* number;   
//弱引用， 当所有指向同一块内存的强指针都赋空时，弱引用失效,为nil  
@property (nonatomic, weak) NSData* data;    
//不安全性弱引用，当所有指向同一块内存的强指针都赋空时，该对象将成为野指针，再次调用会导致程序崩溃  
@property (nonatomic, unsafe_unretained) NSData* data1;    

- (NSString *)string{   
    return _string;   
}

- (void)setString:(NSString*)string{   
    _string = string;   
    //weak,strong,assign 的set方法   
}

- (void)setString:(NSString*)string{   
    if(_string != string) {   
        [_string release];   
        _string = [string retain];   
    }   
    //retain 的set方法   
}

- (void)setString:(NSString*)string{   
    if(_string != string) {   
        [_string release];   
        _string = [string copy];   
    }   
    //copy 的set方法   
}

//释放属性对象   
- (void)dealloc {   
    self.string = nil;   
    [super dealloc];   
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h3 id="arc规则"><a href="#arc规则" class="header-anchor">#</a> ARC规则</h3> <p>不能使用retain/release/retainCount/autorelease<br>
不能使用NSAllocateObject/NSDeallocateObject<br>
须遵守内存管理的方法命名规则</p> <blockquote><p>alloc,new,copy,mutableCopy,init
以init开始的方法的规则要比alloc,new,copy,mutableCopy更严格。该方法必须是实例方法，并且要返回对象。返回的对象应为id类型或方法声明类的对象类型，抑或是该类的超类型或子类型。该返回对象并不注册到autoreleasepool上。基本上只是对alloc方法返回值的对象进行初始化处理并返回该对象。</p></blockquote> <p>不要显式调用dealloc</p> <h3 id="mrc到arc的转变"><a href="#mrc到arc的转变" class="header-anchor">#</a> mrc到arc的转变</h3> <p>引用方式：<br>
copy：拷贝，复制一个对象并创建strong关联，引用计数为1 ，原来对象计数不变。<br>
assign：赋值，不涉及引用计数的变化，弱引用。ARC中对象不使用assign,但原始类型(BOOL、int、float)仍然可以使用。<br>
retain：持有，对原对象引用计数加1，强引用。ARC中使用strong。<br>
weak：赋值（ARC），比assign多了一个功能，对象释放后把指针置为nil，避免了野指针。<br>
strong：持有（ARC），等同于retain。</p> <p>在你打开ARC时，你是不能使用retain、release、autorelease 操作的，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了，但是你需要在对象属性上使用weak 和strong, 其中strong就相当于retain属性，而weak相当于assign，基础类型只需声明非原子锁即可。</p> <h2 id="内存泄露"><a href="#内存泄露" class="header-anchor">#</a> 内存泄露</h2> <h4 id="僵尸对象和野指针"><a href="#僵尸对象和野指针" class="header-anchor">#</a> 僵尸对象和野指针</h4> <p>僵尸对象：内存已经被回收的对象。<br>
野指针：指向僵尸对象的指针，向野指针发送消息会导致崩溃。</p> <h3 id="循环引用"><a href="#循环引用" class="header-anchor">#</a> 循环引用</h3> <p>arc中默认的对象声明都是strong性质的，在两个或两个以上的类相互引用时，会导致循环引用，其中一方需要用weak修饰，才不会造成retainCycle，如：delegate 属性用weak声明；mrc中即用assign修饰 。</p> <ul><li>在block中引用block所属的类、实例变量或类的属性也会导致循环引用</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>self.block = ^{   
        [self doSomething];   
 };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>block是会对内部的对象进行一次retain。也就是说，self会被retain一次。当self释放的时候，需要block释放后才会对self进行释放，但是block的释放又需要等self的dealloc中才会释放。如此一来变形成了循环引用，导致内存泄露。<br>
arc中用__weak修饰self、mrc中用__block修饰,如下代码:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>__weak ViewController* weakSelf = self;//arc   
//__block ViewController* weakSelf = self;//mrc   
self.block = ^{   
   [weakSelf doSomething];   
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>NSTimer的target持有self</li></ul> <blockquote><p>NSTimer会造成循环引用，timer会强引用target即self，一般self又会持有timer作为属性，这样就造成了循环引用。
那么，如果timer只作为局部变量，不把timer作为属性呢？同样释放不了，因为在加入runloop的操作中，timer被强引用。而timer作为局部变量，是无法执行invalidate的，所以在timer被invalidate之前，self也就不会被释放。</p></blockquote> <h4 id="循环中对象占用内存大"><a href="#循环中对象占用内存大" class="header-anchor">#</a> 循环中对象占用内存大</h4> <p>这个问题常见于循环次数较大，循环体生成的对象占用内存较大的情景。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (int i = 0; i &lt; 10000; i ++) {  
  Person * soldier = [[Person alloc]init];   
  [soldier fight];    
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>该循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏，解决方法和上文中提到的自动释放池常见问题类似：在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (int i = 0; i &lt; 10000; i ++) {  
  @autoreleasepool {  
    Person* soldier = [[Person alloc]init];  
    [soldier fight];  
  }  
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>然而有时候autoReleasePool也不是万能的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (int i = 0; i &lt; 2000; i ++) {  
  CGSize size = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%d.jpg&quot;,i]].size;         
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>用imageNamed方法加载图片占用Cache的内存，autoReleasePool也不能释放。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (int i = 0; i &lt; 2000; i ++) {
  @autoreleasepool {
    CGSize size = [UIImage imageWithContentsOfFile:filePath].size;             
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="系统内存警告"><a href="#系统内存警告" class="header-anchor">#</a> 系统内存警告</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    self.view = nil;
    self.data = nil;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="对象型变量作为c语言结构体（struct、union）的成员"><a href="#对象型变量作为c语言结构体（struct、union）的成员" class="header-anchor">#</a> 对象型变量作为C语言结构体（struct、union）的成员</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>struct Data {
    NSMutableArray __unsafe_unretained *array;
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>OC对象型变量如果成为了C语言结构体的成员，那么，ARC不能掌握该对象的生命周期从而有效管理内存，因此，不能这样使用。</p> <h4 id="显式转换-id-和-void"><a href="#显式转换-id-和-void" class="header-anchor">#</a> 显式转换&quot;id&quot; 和 &quot;void*&quot;</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>非ARC下:  
id obj = [[NSObject alloc] init];
void *p = obj;
这样的代码是可行的，id和void*可以方便得自由转化 ，但是，在ARC下是不一样的

ARC下id和void*有三个转换的关键字 __bridge、__bridge_retained、__bridge_transfer:
id obj = [[NSObject alloc] init];
void *p = (__bridge void*)obj;

注意： __bridge不会引起对象的引用计数变化，因此，安全性不太好。相比较，__bridge_retained不仅仅实现了__bridge的功能而且能让p调用retain方法使p持有对象。另外，
__bridge_transfer也是和release方法类似，使用__bridge_transfer进行转化，既让对象p调用一次retain方法，而且原来指针obj会调用一次release方法也非常安全
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="core-foundation-对象"><a href="#core-foundation-对象" class="header-anchor">#</a> Core Foundation 对象</h2> <p>底层的 Core Foundation 对象，在创建时大多以 XxxCreateWithXxx 这样的方式创建，例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 创建一个 CFStringRef 对象
CFStringRef str= CFStringCreateWithCString(kCFAllocatorDefault, “hello world&quot;, kCFStringEncodingUTF8);

// 创建一个 CTFontRef 对象
CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对于这些对象的引用计数的修改，要相应的使用 CFRetain 和 CFRelease 方法。如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 创建一个 CTFontRef 对象
CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);

// 引用计数加 1
CFRetain(fontRef);

// 引用计数减 1
CFRelease(fontRef);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>对于 CFRetain 和 CFRelease 两个方法，读者可以直观地认为，这与 Objective-C 对象的 retain 和 release 方法等价。所以对于底层 Core Foundation 对象，我们只需要延续以前手工管理引用计数的办法即可</p> <h2 id="block内存管理"><a href="#block内存管理" class="header-anchor">#</a> Block内存管理</h2> <p>block本身是像对象一样可以retain，和release。但是，block在创建的时候，它的内存是分配在栈(stack)上，而不是在堆(heap)上。<br>
@property(copy, nonatomic) void(^block)(void);<br>
mrc中 copy会把block从栈上移动到堆上。<br>
@property(strong, nonatomic) void(^block)(void);<br>
arc即时由强引用strong将其从栈复制到堆</p> <h3 id="block-的内存管理："><a href="#block-的内存管理：" class="header-anchor">#</a> block 的内存管理：</h3> <p><img src="/test/assets/img/block1.84bfc4e6.png" alt="block"><br>
当程序运行到这里时，stack 空间中有 shared 变量和 captured 变量。这里可以看出，__block 变量开始是处于stack上的。<br> <img src="/test/assets/img/block2.2607e91f.png" alt="block"><br>
当程序运行到这里时，stack 空间中有 shared 变量，captured 变量和block1。这里可以看出，block 类型的变量开始时也是处在stack上的。<br> <img src="/test/assets/img/block3.985470e2.png" alt="block"><br>
当程序运行到这里时，stack 空间中有 shared 变量，captured 变量和block1。<br>
这里值得注意的就是当我们直接修改stack 上的captured变量时，block1中的captured变量仍然是原来的数值10。事实上，从const 我们就可以看出，block1中的captured变量是不能被修改的而且是从stack原有变量的一个const 拷贝。在block1中访问的captured变量是const拷贝的，也就是说block1中captured = 10，而不是原有的stack上的值 20。当然，在block1中，我们也不能修改captured变量。</p> <h3 id="copy-block"><a href="#copy-block" class="header-anchor">#</a> Copy block</h3> <p>block在一开始是处在stack上的，这是为了考虑到效率的原因，但是，有时候是需要block的生命周期长于一开始的stack，这时，我们就通过copy block 来将block复制到heap。<br> <img src="/test/assets/img/block4.5309feb7.png" alt="block"><br>
当程序执行完 block2 = [block1 copy];时，__block 类型变量shared，被复制到了heap中，很显然，shared变量需要被block和block2共享(当然还有stack也要共享)，而block2被移动到heap中，很可能生命周期会长于stack，所以，shared也被复制到了heap中。而block2中的captured 也被复制到了heap中。<br> <img src="/test/assets/img/block5.d08b4610.png" alt="block"><br>
当程序执行完 block3 = [block2 copy];时, 我们看到的是，block2 和block3 其实指向的是同一片内存空间。事实上，block的数据结构中，保存了引用计数，而对于copy到heap中的block 再copy时，行为同普通对象retain一样，会使引用计数+1。那么如果我们对[block retain]会如何呢？ 实际上什么都没有发生，至少在现在的runtime版本下。因为retain中，不仅有引用计数+1在，而且retain的返回值，必须同返回调用对象的地址一样，而block的地址是可能变化的（stack or heap），所以，这里retain的行为几乎是被忽略掉的。</p> <p>当heap中的block变量先于stack被销毁时，如调用 [block2 release]; [block3 release];，heap中的block2，block3 由于引用计数为0 而被销毁，而 __block 变量shared则还在heap中，因为stack还要使用，block1 也要使用。<br> <img src="/test/assets/img/block6.baf08fab.png" alt="block"><br>
当heap中的block变量晚于stack时，显然，stack 被清除，function中也啥都没了。<br> <img src="/test/assets/img/block7.c6d1a503.png" alt="block"><br>
最后，当block2 和block3 都被release之后。则恢复到最初状态<br> <img src="/test/assets/img/block8.31f89ca3.png" alt="block"></p> <h3 id="block内存类型"><a href="#block内存类型" class="header-anchor">#</a> block内存类型</h3> <h4 id="_1-block内存类型"><a href="#_1-block内存类型" class="header-anchor">#</a> 1.block内存类型</h4> <p>block内存分为三种类型：</p> <ul><li>_NSConcreteGlobalBlock（全局）</li> <li>_NSConcreteStackBlock（栈）</li> <li>_NSConcreteMallocBlock（堆）</li></ul> <h4 id="_2-三种类型的内存的创建时机"><a href="#_2-三种类型的内存的创建时机" class="header-anchor">#</a> 2.三种类型的内存的创建时机</h4> <h5 id="_1）对于-nsconcretestackblock和-nsconcreteglobalblock类型"><a href="#_1）对于-nsconcretestackblock和-nsconcreteglobalblock类型" class="header-anchor">#</a> 1）对于_NSConcreteStackBlock和_NSConcreteGlobalBlock类型</h5> <p>_NSConcreteStackBlock和_NSConcreteGlobalBlock这两种类型的block，我们可以手动创建，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>void (^globalBlock)() = ^{

};

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^stackBlock1)() = ^{

        };
    }
    return 0;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么我们怎么确定这两个block，就是我们所说的两种类型的block呢，我们可以使用clang -rewrite-objc xxx.m（报错可以使用详细命令： clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xxxxx.m）编译转换成C++实现，就可以看到转换完的结果，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// globalBlock
struct __globalBlock_block_impl_0 {
  struct __block_impl impl;
  struct __globalBlock_block_desc_0* Desc;
  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteGlobalBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
...

// stackBlock
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
...
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        void (*stackBlock)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
    }
    return 0;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>可以看出可以看出globalBlock是_NSConcreteGlobalBlock类型，即在全局区域创建，block变量存储在全局数据存储区；stackBlock是_NSConcreteStackBlock类型，即在栈区创建。</p> <h5 id="_2）对于-nsconcretemallocblock类型"><a href="#_2）对于-nsconcretemallocblock类型" class="header-anchor">#</a> 2）对于_NSConcreteMallocBlock类型</h5> <p>NSConcreteMallocBlock类型的内存是通过_NSConcreteStackBlock类型的block copy得到的，那么哪些类型会对block进行copy呢？</p> <ul><li>block作为返回值</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 如果是weak类型的block，依然不会自动进行copy
// &lt;__NSStackBlock__: 0x7fff5fbff728&gt;
__weak void (^weakBlock)() = ^{i;};

// ARC情况下输出
// &lt;__NSMallocBlock__
NSLog(@&quot;%@&quot;, [self callBack:weakBlock]);
- (id)callBack:(void (^)(void))callBack
{
     NSLog(@&quot;%@&quot;, callBack);

    return callBack;
}

//输出结果
&lt;__NSStackBlock__: 0x7ffee2559838&gt;
&lt;__NSMallocBlock__: 0x600003a99ce0&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>block作为属性，使用copy修饰时(strong修饰符不会改变block内存类型)</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>@property (copy, nonatomic) id myCopyBlock;
@property (strong, nonatomic) id myStrongBlock;

// 如果是weak类型的block，依然不会自动进行copy
// &lt;__NSStackBlock__: 0x7fff5fbff728&gt;
__weak void (^weakBlock)() = ^{i;};
NSLog(@&quot;%@&quot;, weakBlock);

//会进行copy操作
//&lt;__NSMallocBlock__: 0x6000037e8db0&gt;
self.myCopyBlock  = weakBlock;
NSLog(@&quot;%@&quot;, self.myCopyBlock);

// 会进行strong操作
// &lt;__NSStackBlock__: 0x7fff5fbff728&gt;
self.myStrongBlock  = weakBlock;
NSLog(@&quot;%@&quot;, self.myStrongBlock);

//打印结果
//&lt;__NSStackBlock__: 0x7ffee8ed5838&gt;
//&lt;__NSMallocBlock__: 0x6000037e8db0&gt;
//&lt;__NSStackBlock__: 0x7ffee8ed5838&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ul><li>block为strong类型，且捕获了外部变量时。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int i = 10;
void (^block)() = ^{i;};
// 因为block为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy
// &lt;__NSMallocBlock__: 0x100206920&gt;
NSLog(@&quot;%@&quot;, block);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>对于作为参数传递的block，其类型是什么呢？</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int i = 10;
void (^block)() = ^{i;};
__weak void (^weakBlock)() = ^{i;};
void (^stackBlock)() = ^{};
// ARC情况下

// 创建时，都会在栈中
// &lt;__NSStackBlock__: 0x7fff5fbff730&gt;
NSLog(@&quot;%@&quot;, ^{i;});

// 因为block为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy
// &lt;__NSMallocBlock__: 0x100206920&gt;
NSLog(@&quot;%@&quot;, block);

// 如果是weak类型的block，依然不会自动进行copy
// &lt;__NSStackBlock__: 0x7fff5fbff728&gt;
NSLog(@&quot;%@&quot;, weakBlock);

// 如果block是strong类型，并且没有捕获外部变量，那么就会转换成__NSGlobalBlock__
// &lt;__NSGlobalBlock__: 0x100001110&gt;
NSLog(@&quot;%@&quot;, stackBlock);

[self callBack:weakBlock];
[self callBack:block];
[self callBack:stackBlock];

- (id)callBack:(void (^)(void))callBack
{
     NSLog(@&quot;%@&quot;, callBack);

    return callBack;
}

//结果
 //&lt;__NSStackBlock__: 0x7ffee2572838&gt;
//&lt;__NSMallocBlock__: 0x600002e881e0&gt;
// &lt;__NSGlobalBlock__: 0x10d68c0f8&gt;

//&lt;__NSStackBlock__: 0x7ffee2572838&gt;
//&lt;__NSMallocBlock__: 0x600002e881e0&gt;
//&lt;__NSGlobalBlock__: 0x10d68c0f8&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>我们可以发现函数参数的block为什么类型，block在函数中就是什么类型。</p> <h2 id="autorelease内存管理"><a href="#autorelease内存管理" class="header-anchor">#</a> Autorelease内存管理</h2> <h3 id="_1、哪些对象是autorelease管理的？"><a href="#_1、哪些对象是autorelease管理的？" class="header-anchor">#</a> 1、哪些对象是autorelease管理的？</h3> <h4 id="_1、enumerateobjectsusingblock中的对象"><a href="#_1、enumerateobjectsusingblock中的对象" class="header-anchor">#</a> 1、enumerateObjectsUsingBlock中的对象</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>[NSArray array] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
//自动缓存池
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="_2、-autoreleasing-修饰的对象"><a href="#_2、-autoreleasing-修饰的对象" class="header-anchor">#</a> 2、__autoreleasing 修饰的对象</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>id obj = [NSObject new];
id __autoreleasing o = obj;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_3、array、dictiongnary、stringwithstring等非init或者new方法生成的对象"><a href="#_3、array、dictiongnary、stringwithstring等非init或者new方法生成的对象" class="header-anchor">#</a> 3、array、dictiongnary、stringWithString等非init或者new方法生成的对象</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>int main(int argc, char * argv[]) {
NSMutableArray *array = [NSMutableArray array];
NSMutableArray *array1 = [NSMutableArray arrayWithCapacity:5];
NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSMutableString *str = [NSMutableString stringWithString:@&quot;dsdsds&quot;];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>以上类型实验结果：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>int main(int argc, char * argv[]) {
      id obj = [NSObject new];
      id __autoreleasing o = obj;
      id __autoreleasing o1 = obj;

    NSMutableArray *array = [NSMutableArray arrayWithCapacity:5];
    [array addObject:@&quot;0&quot;];
    [array addObject:@&quot;1&quot;];
    [array addObject:@&quot;2&quot;];
    [array addObject:@&quot;3&quot;];
    [array addObject:@&quot;4&quot;];
    [array addObject:@&quot;5&quot;];
    [array addObject:@&quot;6&quot;];

    NSMutableArray *array1 = [NSMutableArray array];
    [array1 addObject:@&quot;11&quot;];
    [array1 addObject:@&quot;12&quot;];
    [array1 addObject:@&quot;13&quot;];
    [array1 addObject:@&quot;14&quot;];
    [array1 addObject:@&quot;15&quot;];
    [array1 addObject:@&quot;16&quot;];
    [array1 enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        id __autoreleasing o = obj;
    }];

    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    [dict setObject:@&quot;1&quot; forKey:@&quot;1&quot;];

    NSMutableString *str = [NSMutableString stringWithString:@&quot;dsdsds&quot;];
//   _objc_autoreleasePoolPrint()
}

//在armv7上、使用_objc_autoreleasePoolPrint()调试打印结果
(lldb) po _objc_autoreleasePoolPrint()
objc[96185]: ##############
objc[96185]: AUTORELEASE POOLS for thread 0x20d080
objc[96185]: 6 releases pending.
objc[96185]: [0x7e115000]  ................  PAGE  (hot) (cold)
objc[96185]: [0x7e115028]        0x7be71ca0  NSObject
objc[96185]: [0x7e11502c]        0x7be71ca0  NSObject
objc[96185]: [0x7e115030]        0x7c470560  __NSArrayM
objc[96185]: [0x7e115034]        0x7be723b0  __NSArrayM
objc[96185]: [0x7e115038]        0x7c170b80  __NSDictionaryM
objc[96185]: [0x7e11503c]        0x7be72540  __NSCFString
objc[96185]: ##############
0x0a5c2500

//在arm64的手机上、使用_objc_autoreleasePoolPrint()调试打印结果
(lldb) po _objc_autoreleasePoolPrint()
objc[96400]: ##############
objc[96400]: AUTORELEASE POOLS for thread 0x1151d75c0
objc[96400]: 5 releases pending.
objc[96400]: [0x7fae43000000]  ................  PAGE  (hot) (cold)
objc[96400]: [0x7fae43000038]    0x600003a6c840  __NSArrayI//系统创建对象
objc[96400]: [0x7fae43000040]    0x600000c358b0  __NSSetI//系统创建对象
objc[96400]: [0x7fae43000048]    0x600002d380d0  NSObject
objc[96400]: [0x7fae43000050]    0x600002d380d0  NSObject
objc[96400]: [0x7fae43000058]    0x6000021649f0  __NSArrayM
objc[96400]: ##############
0xe0675b6edaa1003f

(lldb) po 0x6000021649f0
&lt;__NSArrayM 0x600001435d70&gt;(
0,
1,
2,
3,
4,
5,
6
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br></div></div><p>注意:这里面的实验结果不一样，在arm64上、array、dictiongnary、stringWithString等方法生成的对象,在自动缓存池中只能看见第一个对象，而armv7的机型上，可以看见所有的，不知这里是什么原因<br>
两个常用的调试命令</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//打印自动缓存池对象
_objc_autoreleasePoolPrint()
//打印引用计数
_objc_rootRetainCount（obj）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_2、autoreleasepool什么时候创建的，里面的对象又是什么时候释放的？"><a href="#_2、autoreleasepool什么时候创建的，里面的对象又是什么时候释放的？" class="header-anchor">#</a> 2、autoreleasePool什么时候创建的，里面的对象又是什么时候释放的？</h3> <h4 id="_1、系统通过runloop创建的autoreleasepool"><a href="#_1、系统通过runloop创建的autoreleasepool" class="header-anchor">#</a> 1、系统通过runloop创建的autoreleasePool</h4> <p>runloop 可以说是iOS 系统的灵魂。内存管理／UI 刷新／触摸事件这些功能都需要 runloop 去管理和实现。runloop是通过线程创建的，和线程保持一对一的关系，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。<br> <strong>runloop和autoreleasePool又是什么关系呢？对象又是什么时候释放的？</strong><br>
App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p> <p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p> <p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p> <p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。<br> <strong>验证结果：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>int main(int argc, char * argv[]) {
    id obj = [NSObject new];
    id __autoreleasing o = obj;
    id __autoreleasing o1 = obj;

    NSMutableArray *array = [NSMutableArray arrayWithCapacity:5];
    [array addObject:@&quot;0&quot;];
    [array addObject:@&quot;1&quot;];
    [array addObject:@&quot;2&quot;];
    [array addObject:@&quot;3&quot;];
    [array addObject:@&quot;4&quot;];
    [array addObject:@&quot;5&quot;];
    [array addObject:@&quot;6&quot;];
//   _objc_autoreleasePoolPrint()
}

//_objc_autoreleasePoolPrint调试打印结果
(lldb) po _objc_autoreleasePoolPrint()
objc[99121]: ##############
objc[99121]: AUTORELEASE POOLS for thread 0x107b0d5c0
objc[99121]: 5 releases pending.
objc[99121]: [0x7f93b2002000]  ................  PAGE  (hot) (cold)
objc[99121]: [0x7f93b2002038]    0x6000000d66c0  __NSArrayI
objc[99121]: [0x7f93b2002040]    0x6000036b9680  __NSSetI
objc[99121]: [0x7f93b2002048]    0x600001780160  NSObject
objc[99121]: [0x7f93b2002050]    0x600001780160  NSObject
objc[99121]: [0x7f93b2002058]    0x600001bcd230  __NSArrayM
objc[99121]: ##############
0x67c4279ea7c20079

(lldb) po 0x600001bcd230
&lt;__NSArrayM 0x600001bcd230&gt;(
0,
1,
2,
3,
4,
5,
6
)

(lldb) po [NSThread currentThread]
&lt;NSThread: 0x6000000953c0&gt;{number = 1, name = main}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h4 id="_2、手动autoreleasepool"><a href="#_2、手动autoreleasepool" class="header-anchor">#</a> 2、手动autoreleasePool</h4> <p>我们可以通过@autoreleasepool {}方式手动创建autoreleasepool对象，那么这个对象什么时候释放呢？答案是除了autoreleasepool的大括号就释放了，我们可以看下下面的实验结果</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>int main(int argc, char * argv[]) {

 //1.   _objc_autoreleasePoolPrint()   
    @autoreleasepool {
        id obj = [NSObject new];
        id __autoreleasing o = obj;
        id __autoreleasing o1 = obj;
//2.   _objc_autoreleasePoolPrint()
    }
//3.   _objc_autoreleasePoolPrint()
}

 //1.   _objc_autoreleasePoolPrint()  
(lldb) po _objc_autoreleasePoolPrint()
objc[1555]: ##############
objc[1555]: AUTORELEASE POOLS for thread 0x11331a5c0
objc[1555]: 2 releases pending.
0x2196ee78f1e100fd

objc[1555]: [0x7fc2a9802000]  ................  PAGE  (hot) (cold)
objc[1555]: [0x7fc2a9802038]    0x600002dbb600  __NSArrayI
objc[1555]: [0x7fc2a9802040]    0x600001bd8a50  __NSSetI
objc[1555]: ##############

 //2.   _objc_autoreleasePoolPrint()  
(lldb) po _objc_autoreleasePoolPrint()
objc[1555]: ##############
objc[1555]: AUTORELEASE POOLS for thread 0x11331a5c0
0x2196ee78f1e100fd

objc[1555]: 5 releases pending.
objc[1555]: [0x7fc2a9802000]  ................  PAGE  (hot) (cold)
objc[1555]: [0x7fc2a9802038]    0x600002dbb600  __NSArrayI
objc[1555]: [0x7fc2a9802040]    0x600001bd8a50  __NSSetI
objc[1555]: [0x7fc2a9802048]  ################  POOL 0x7fc2a9802048
objc[1555]: [0x7fc2a9802050]    0x600003afc030  NSObject
objc[1555]: [0x7fc2a9802058]    0x600003afc030  NSObject
objc[1555]: ##############

 //3.   _objc_autoreleasePoolPrint()  
(lldb) po _objc_autoreleasePoolPrint()
objc[1555]: ##############
objc[1555]: AUTORELEASE POOLS for thread 0x11331a5c0
0x2196ee78f1e100fd

objc[1555]: 2 releases pending.
objc[1555]: [0x7fc2a9802000]  ................  PAGE  (hot) (cold)
objc[1555]: [0x7fc2a9802038]    0x600002dbb600  __NSArrayI
objc[1555]: [0x7fc2a9802040]    0x600001bd8a50  __NSSetI
objc[1555]: ##############
(lldb)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>从上面1、2、3的结果可以看出，当对象出了autoreleasepool的大括号就释放了。</p> <h4 id="_3、子线程的autoreleasepool对象的管理？"><a href="#_3、子线程的autoreleasepool对象的管理？" class="header-anchor">#</a> 3、子线程的autoreleasepool对象的管理？</h4> <p>线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。所以在我们创建子线程的时候，如果没有获取runloop，那么也就没用通过runloop来创建autoreleasepool，那么我们的autorelease对象是怎么管理的，会不会存在内存泄漏呢？答案是否定的，当子线程有autoreleasepool的时候，autorelease对象通过其来管理，如果没有autoreleasepool，会通过调用 autoreleaseNoPage 方法，将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！这部分我们可以看下runtime中NSObject.mm的部分，有相关代码。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>static inline id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    if (page &amp;&amp; !page-&gt;full()) {
        return page-&gt;add(obj);
    } else if (page) {
        return autoreleaseFullPage(obj, page);
    } else {
        //调用 autoreleaseNoPage 方法管理autorelease对象。
        return autoreleaseNoPage(obj);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="weak对象内存管理"><a href="#weak对象内存管理" class="header-anchor">#</a> weak对象内存管理</h2> <h3 id="_1、释放时机"><a href="#_1、释放时机" class="header-anchor">#</a> 1、释放时机</h3> <p>在dealloc的时候，会将weak属性的值设置为nil</p> <h3 id="_2、如何实现"><a href="#_2、如何实现" class="header-anchor">#</a> 2、如何实现</h3> <p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针，对于 weak 对象会放入一个 hash 表中,Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。
注：由于可能多个weak指针指向同一个对象，所以value为一个数组</p> <p><strong>weak 的实现原理可以概括以下三步：</strong></p> <h4 id="_1、初始化时：runtime会调用objc-initweak函数，初始化一个新的weak指针指向对象的地址。"><a href="#_1、初始化时：runtime会调用objc-initweak函数，初始化一个新的weak指针指向对象的地址。" class="header-anchor">#</a> 1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。</h4> <p>我们以下面这行代码为例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    id __weak obj1 = obj;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当我们初始化一个weak变量时，runtime会调用objc_initWeak函数。这个函数在Clang中的声明如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>id objc_initWeak(id *object, id value);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其具体实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>id objc_initWeak(id *object, id value)
{
    *object = 0;
    return objc_storeWeak(object, value);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>示例代码轮换成编译器的模拟代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>id obj1;
objc_initWeak(&amp;obj1, obj);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>因此，这里所做的事是先将obj1初始化为0(nil)，然后将obj1的地址及obj作为参数传递给objc_storeWeak函数。
objc_initWeak函数有一个前提条件：就是object必须是一个没有被注册为__weak对象的有效指针。而value则可以是null，或者指向一个有效的对象。</p> <h4 id="_2、添加引用时：objc-initweak函数会调用-objc-storeweak-函数。"><a href="#_2、添加引用时：objc-initweak函数会调用-objc-storeweak-函数。" class="header-anchor">#</a> 2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数。</h4> <p>objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</p> <h4 id="_3、释放时，调用cleardeallocating函数。"><a href="#_3、释放时，调用cleardeallocating函数。" class="header-anchor">#</a> 3、释放时，调用clearDeallocating函数。</h4> <p>clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p> <h2 id="nsstring内存管理"><a href="#nsstring内存管理" class="header-anchor">#</a> NSString内存管理</h2> <h3 id="_1、nsstring内存的类型"><a href="#_1、nsstring内存的类型" class="header-anchor">#</a> 1、NSString内存的类型</h3> <p>NSString内存分为两种类型：</p> <ul><li>__NSCFConstantString（常量区）</li> <li>__NSCFString（堆区）、NSTaggedPointerString（堆区）</li></ul> <h3 id="_2、两种内存类型的创建时机。"><a href="#_2、两种内存类型的创建时机。" class="header-anchor">#</a> 2、两种内存类型的创建时机。</h3> <p>生成一个NSString类型的字符串有三种方法:</p> <ul><li>方法1.直接赋值:</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code> NSString *str1 = @&quot;my string&quot;;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>方法2.类函数初始化生成:</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>NSString *str2 = [NSString stringWithString:@&quot;my string&quot;];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>方法3.实例方法初始化生成:</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>NSString *str3 = [[NSString alloc] initWithString:@&quot;my string&quot;];
NSString *str4 = [[NSString alloc]initWithFormat:@&quot;my string&quot;];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_1、对于-nscfconstantstring"><a href="#_1、对于-nscfconstantstring" class="header-anchor">#</a> 1、对于__NSCFConstantString</h4> <p>这种类型的字符串是常量字符串。该类型的字符串以字面量的方式创建，保存在字符串常量区，是在编译时创建的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>NSString *a = @&quot;str&quot;;
NSString *b = [[NSString alloc]init];
NSString *c = [[NSString alloc]initWithString:@&quot;str&quot;];
NSString *d = [NSString stringWithString:@&quot;str&quot;];

NSLog(@&quot;%@ : class = %@&quot;,a,NSStringFromClass([a class]));
NSLog(@&quot;%@ : class = %@&quot;,b,NSStringFromClass([b class]));
NSLog(@&quot;%@ : class = %@&quot;,c,NSStringFromClass([c class]));
NSLog(@&quot;%@ : class = %@&quot;,d,NSStringFromClass([d class]));

//打印结果
2019-06-23 19:23:13.240611+0800 BlockDemo[47229:789011] str : class = __NSCFConstantString
2019-06-23 19:23:13.240764+0800 BlockDemo[47229:789011]  : class = __NSCFConstantString
2019-06-23 19:23:13.240870+0800 BlockDemo[47229:789011] str : class = __NSCFConstantString
2019-06-23 19:23:13.240957+0800 BlockDemo[47229:789011] str : class = __NSCFConstantString
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="_2、对于-nscfstring和nstaggedpointerstring"><a href="#_2、对于-nscfstring和nstaggedpointerstring" class="header-anchor">#</a> 2、对于__NSCFString和NSTaggedPointerString</h4> <ul><li>__NSCFString 表示对象类型的字符串，在运行时创建，保存在堆区，初始引用计数为1，其内存管理方式就是对象的内存管理方式。</li> <li>NSTaggedPointerString是对__NSCFString类型的一种优化，在运行创建字符串时，会对字符串内容及长度作判断，若内容由ASCII字符构成且长度较小（具体要多小暂时不太清楚），这时候创建的字符串类型就是 NSTaggedPointerString<br> <strong>对于不可以变NSString的测试结果：</strong></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>NSString *e = [[NSString alloc]initWithFormat:@&quot;str&quot;];
NSString *f = [NSString stringWithFormat:@&quot;str&quot;];
NSString *g = [NSString stringWithFormat:@&quot;123456789&quot;];
NSString *h = [NSString stringWithFormat:@&quot;1234567890&quot;];

NSLog(@&quot;%@ : class = %@&quot;,e,NSStringFromClass([e class]));
NSLog(@&quot;%@ : class = %@&quot;,f,NSStringFromClass([f class]));
NSLog(@&quot;%@ : class = %@&quot;,g,NSStringFromClass([g class]));
NSLog(@&quot;%@ : class = %@&quot;,h,NSStringFromClass([h class]));

//打印结果
2019-06-23 19:27:19.115212+0800 BlockDemo[48129:794364] str : class = NSTaggedPointerString
2019-06-23 19:27:19.115286+0800 BlockDemo[48129:794364] str : class = NSTaggedPointerString
2019-06-23 19:27:19.115388+0800 BlockDemo[48129:794364] 123456789 : class = NSTaggedPointerString
2019-06-23 19:27:19.115476+0800 BlockDemo[48129:794364] 1234567890 : class = __NSCFString
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>对于可变的NSMutableString</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>NSMutableString *ms1 = [[NSMutableString alloc]init];
NSMutableString *ms2 = [[NSMutableString alloc]initWithString:@&quot;str&quot;];
NSMutableString *ms3 = [[NSMutableString alloc]initWithFormat:@&quot;str&quot;];
NSMutableString *ms4 = [NSMutableString stringWithFormat:@&quot;str&quot;];
NSMutableString *ms5 = [NSMutableString stringWithFormat:@&quot;123456789&quot;];
NSMutableString *ms6 = [NSMutableString stringWithFormat:@&quot;1234567890&quot;];

NSLog(@&quot;%@ : class = %@&quot;,ms1,NSStringFromClass([ms1 class]));
NSLog(@&quot;%@ : class = %@&quot;,ms2,NSStringFromClass([ms2 class]));
NSLog(@&quot;%@ : class = %@&quot;,ms3,NSStringFromClass([ms3 class]));
NSLog(@&quot;%@ : class = %@&quot;,ms4,NSStringFromClass([ms4 class]));
NSLog(@&quot;%@ : class = %@&quot;,ms5,NSStringFromClass([ms5 class]));
NSLog(@&quot;%@ : class = %@&quot;,ms6,NSStringFromClass([ms6 class]));

//打印结果
2019-06-23 19:34:08.521931+0800 BlockDemo[49465:802590]  : class = __NSCFString
2019-06-23 19:34:08.522058+0800 BlockDemo[49465:802590] str : class = __NSCFString
2019-06-23 19:34:08.522131+0800 BlockDemo[49465:802590] str : class = __NSCFString
2019-06-23 19:34:08.522196+0800 BlockDemo[49465:802590] str : class = __NSCFString
2019-06-23 19:34:08.522281+0800 BlockDemo[49465:802590] 123456789 : class = __NSCFString
2019-06-23 19:34:08.522372+0800 BlockDemo[49465:802590] 1234567890 : class = __NSCFString
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>从结果我们可以看出来NSMutableString都是分配在堆区，且是__NSCFString类型，NSString中Format相关方法也是都分配在堆区，但是会根据字符串的长度，区分为__NSCFString和NSTaggedPointerString两种。在分配堆区的这些变量，其实一部分是正常的对象，一部分变成autorelease对象，具体是哪些，我们可以使用_objc_autoreleasePoolPrint()打印出来，比如实例中的g、ms4、ms5、ms6。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/blog/" class="prev router-link-active">
        关于
      </a></span> <span class="next"><a href="/test/blog/Other/Mark.html">
        Mark
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test/assets/js/app.d0cc9b25.js" defer></script><script src="/test/assets/js/2.9ead390f.js" defer></script><script src="/test/assets/js/3.3a99d1c0.js" defer></script>
  </body>
</html>
